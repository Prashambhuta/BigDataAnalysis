# -*- coding: utf-8 -*-
"""paralelization_task_in_class.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fam6cpuyPbixllq5wJrcA0R3cBgY8suv
"""

import multiprocessing as mp

print(mp.cpu_count())

import numpy as np
from time import time

np.random.RandomState(1)
arr = np.random.randint(0, 10, size=[10000, 10])
data = arr.tolist()
print(data[:5])

def count_even(one_row):
  e = 0
  for i in one_row:
    if i%2 == 0:
      e+=1
  return e

results = []

for row in data:
  e = count_even(row)
  results.append(e)

sum(results)

cpu_pool = mp.Pool(mp.cpu_count())
results = [cpu_pool.apply(count_even, args = (row, )) for row in data]

sum(results)

results = cpu_pool.starmap(count_even, [(row, ) for row in data])

sum(results)

global results2
results2 = []

def gather_results(result):
  global results2
  results2.append(result)

cpu_pool = mp.Pool(mp.cpu_count())

for i, row in enumerate(data):
  cpu_pool.apply_async(count_even, args=(row, i), callback = gather_results)

cpu_pool.close()
cpu_pool.join()

print(sum([x[1] for x in results2]))

def count_even(one_row, i):
  e = 0
  for y in one_row:
    if y%2 == 0:
      e+=1
  return (i, e)